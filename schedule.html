<script>
let time = 0;
let end_time = 2000000;
let frame_count = 0;
let frame_delay = 0;
let log = console.log;

class Queue extends Array {
    constructor() {
        super();
        this.current = undefined;
        this.next_time = 0;
    }

    run(time) {
        let result = undefined;
        if (this.next_time <= time) {
            if (this.current) {
                result = this.shift();
                result.finish_times.push(time);
                this.current = undefined;
            }
        }
        return result;
    }

    schedule(time) {
        if (this.next_time <= time && this.length && !this.current) {
            this.current = this[0];
            this.current.start_times.push(time);
            this.next_time = this.current.length.shift() + time
        }
    }

    push(frame) {
        frame.enqueue_times.push(time);
        super.push(frame)
    }
}

class Frame {
    constructor(start_time, length) {
        this.start_time = start_time;
        this.length = length;
        this.end_time = 0;
        this.enqueue_times = [];
        this.start_times = [];
        this.finish_times = [];
    }
}

let main_thread = new Queue();
let pending_composite = [];
let compositor = new Queue();
let renderer = new Queue();
let scene_builder = new Queue();

const COMPOSITOR_SCHEDULE_ON_VSYNC = false;

let total_live_frames = 0;
let compositor_live_frames = 0;
let finished_frames = [];
let frame_no = 0;

while (time < end_time) {
    if (time % 16666 == 0) {
        // vsync
        if (pending_composite.length) {
            if (pending_composite.length > 1) {
                console.log("skipping frames for composite");
            }
            if (compositor.length) {
                compositor_live_frames++;
                compositor.push(pending_composite.pop());
                pending_composite = [];
            }
        } 

        const MAX_QUEUE_LENGTH = 1;
        if ((scene_builder.length < 1 || scene_builder.current) && main_thread.length < 1) {
            console.log(frame_no, renderer.length);
            main_thread.push(new Frame(time, [30*1000, 8*1000, 14*1000, 39*1000]));

            total_live_frames++;
            frame_no++;
        } else {
            console.log("skipped scheduling frame", main_thread.length, scene_builder.length, compositor.length, renderer.length);
        }
    }

    main_thread.schedule(time);
    let finished_frame = main_thread.run(time);

    if (finished_frame) {
        scene_builder.push(finished_frame);
    }

    if (compositor.length < 1 || compositor.current) {
        scene_builder.schedule(time);
    }

    finished_frame = scene_builder.run(time);

    if (finished_frame) {
        if (COMPOSITOR_SCHEDULE_ON_VSYNC) {
            pending_composite.push(finished_frame);
        } else {
            compositor_live_frames++;
            log("push compositor");
            compositor.push(finished_frame);
        }
    }

    if ((renderer.length < 1 || renderer.current) && renderer.length <= 1) {
        compositor.schedule(time);
    }
    finished_frame = compositor.run(time);

    if (finished_frame) {
        log("push renderer")
        renderer.push(finished_frame);
    }

    renderer.schedule(time);
    finished_frame = renderer.run(time);

    if (finished_frame) {
        log("finish frame")
        total_live_frames--;
        compositor_live_frames--;
        frame_count++;
        frame_delay += (time - finished_frame.start_time);
        finished_frame.end_time = time;
        finished_frames.push(finished_frame);
    }
    time++;
}

zip = (...rows) => [...rows[0]].map((_, c)=>rows.map(row => row[c]))
log(frame_count);
log(1000*1000 * frame_count / end_time, "fps");
log(frame_delay / (frame_count * 10000), "ms", (frame_delay / (frame_count * 1000.0)) / (1000/60.), "frames");

document.open();
let writeln = document.writeln.bind(document);
writeln("<div style='position: relative; height:40px'>");
writeln("<style>.frame:hover { background: red } .frame { background: black; color: green; } .schedule { background: rgba(128, 128, 128, 0.5) } .vsync { background: blue }</style>");
function print_times(frames) {
    frame_no = 0;
    colors = ["rgba(255, 0, 0, 0.5)", "rgba(0, 255, 0, 0.5)", "rgba(0, 0, 255, 0.5)"];
    for (let frame of frames) {
        color = colors[frame_no % colors.length];
        let top = 0;
        writeln(`<div class='frame'
         style='position: absolute;
            top: ${top}px;
            left: ${frame.start_time/1000.}px;
            width: ${(frame.end_time - frame.start_time)/1000.}px;
            height:40px; background: ${color}'>${frame_no}</div>`);
        top += 42;
        for (let times of zip(frame.enqueue_times, frame.start_times, frame.finish_times)) {
            top += 10;
            writeln(`<div class='frame'
                style='position: absolute;
                top: ${top}px;
                left: ${times[1]/1000.}px;
                width: ${(times[2]-times[1])/1000.}px;
                height:20px; background: ${color}'></div>`);
            top -= 10;
            writeln(`<div class='frame schedule'
                style='position: absolute;
                top: ${top}px;
                left: ${times[0]/1000.}px;
                width: ${(times[2]-times[0])/1000.}px;
                height:10px'>${frame_no}</div>`);
            top += 32;
        }
        frame_no++;
    }
}

print_times(finished_frames);

let vsync_time = 0;
while (vsync_time < end_time) {
    if (vsync_time % 16666 == 0) {
        writeln(`<div class='vsync' style='position: absolute; left: ${vsync_time/1000.}px; top: 0px; width: 1px; height:800px'></div>`);
    }
    vsync_time++;
}

writeln("</div>");
</script>
